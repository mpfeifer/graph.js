// This class serves as the foundation for javascript applications that
// build upon the html5 canvas. The canvas to use is specified in the 
// class constructor by canvasname parameter.


/*

 Need cleaner seperation of concerns: Who is editing graph?
 idea: clickhandler emits actions
 designer: executes actions
 actions can be undone
 logentries get action infos and set selection according


 #####  Color Palette by Paletton.com
 #####  Palette URL: http://paletton.com/#uid=72Z0u0kllllaCvbfZqgqyghwabv


 *** Primary color:

 shade 0 = #28794C = rgb( 40,121, 76) = rgba( 40,121, 76,1)
 shade 1 = #76B190 = rgb(118,177,144) = rgba(118,177,144,1)
 shade 2 = #4B956B = rgb( 75,149,107) = rgba( 75,149,107,1)
 shade 3 = #105C31 = rgb( 16, 92, 49) = rgba( 16, 92, 49,1)
 shade 4 = #00411C = rgb(  0, 65, 28) = rgba(  0, 65, 28,1)

 *** Secondary color (1):

 shade 0 = #27556C = rgb( 39, 85,108) = rgba( 39, 85,108,1)
 shade 1 = #6C8D9D = rgb(108,141,157) = rgba(108,141,157,1)
 shade 2 = #467084 = rgb( 70,112,132) = rgba( 70,112,132,1)
 shade 3 = #113D52 = rgb( 17, 61, 82) = rgba( 17, 61, 82,1)
 shade 4 = #03283A = rgb(  3, 40, 58) = rgba(  3, 40, 58,1)

 *** Secondary color (2):

 shade 0 = #AA7539 = rgb(170,117, 57) = rgba(170,117, 57,1)
 shade 1 = #F8D2A6 = rgb(248,210,166) = rgba(248,210,166,1)
 shade 2 = #D1A169 = rgb(209,161,105) = rgba(209,161,105,1)
 shade 3 = #825016 = rgb(130, 80, 22) = rgba(130, 80, 22,1)
 shade 4 = #5C3100 = rgb( 92, 49,  0) = rgba( 92, 49,  0,1)

 *** Complement color:

 shade 0 = #AA5039 = rgb(170, 80, 57) = rgba(170, 80, 57,1)
 shade 1 = #F8B7A6 = rgb(248,183,166) = rgba(248,183,166,1)
 shade 2 = #D17F69 = rgb(209,127,105) = rgba(209,127,105,1)
 shade 3 = #822D16 = rgb(130, 45, 22) = rgba(130, 45, 22,1)
 shade 4 = #5C1300 = rgb( 92, 19,  0) = rgba( 92, 19,  0,1)


 #####  Generated by Paletton.com (c) 2002-2014

 */

function LogEntry(action) {
	this.action = action;
	this.selected = 0;
};

LogEntry.prototype.select = function() {
	this.selected = 1;
};

LogEntry.prototype.unselect = function() {
	this.selected = 0;
};

var Logbook = Logbook || {};

Logbook.logentries = [];
Logbook.logentriesDivs = [];
Logbook.selectedIndex = -1;
Logbook.logbookDiv = document.getElementById("innerlogbook");

Logbook.onMouseOverEntry = function(evt) {
};

Logbook.onMouseLeavesEntry = function(evt) {
};

Logbook.onEntryClicked = function(evt) {
};

Logbook.append = function(action) {
	var newDiv = document.createElement("div");
	newDiv.innerHTML = "•" + action.logMsg;
	newDiv.className = "logentry";
	newDiv.addEventListener("mouseover", Logbook.onMouseOverEntry);
	newDiv.addEventListener("mouseout", Logbook.onMouseLeavesEntry);
	newDiv.addEventListener("click", Logbook.OnEntryClicked);
	Logbook.logentries.push(action);
	Logbook.logentriesDivs.push(newDiv);
	Logbook.logbookDiv.appendChild(newDiv);
	Logbook.logbookDiv.scrollBy(0, 100);
};

var Clickhandler = Clickhandler || {};

function SelectionChangeAction(selection) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0 ;
	this.affectedNodes = [];
	this.timestamp = undefined;
	this.graph = undefined;
	this.affectedNodes = selection.slice();
};

SelectionChangeAction.prototype.buildLogMsg = function() {
	var ids = "";
	for(var i = 0; i < this.affectedNodes.length; i++) {
		ids += "" + this.affectedNodes[i].id;
		if (i+1 < this.affectedNodes.length) {
			ids += ", ";
		}
	}
	this.logMsg = "Selection changed [" + ids + "]";
};

SelectionChangeAction.prototype.apply = function(graph) {

	this.graph = graph.clone();
	
	graph.selection = this.affectedNodes.slice();
	
	this.applied = 1;
	this.timestampe = new Date();
	this.buildLogMsg();

	if (State.debug) {
		alert(this.logMsg);
	}
};

SelectionChangeAction.prototype.undo = function() {
	Designer.graph = this.graph.clone();
	Designer.redraw();
};

function CreateNodeAction(x, y) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.affectedNodes = [];
	this.timestamp = undefined;
	this.x = x;
	this.y = y;
	this.graph = undefined;
}

CreateNodeAction.prototype.buildLogMsg = function(node) {
	this.logMsg = "New node created (id=" + node.id + ")";
};

CreateNodeAction.prototype.apply = function(graph) {

	this.graph = graph.clone();
	
	var newNode = graph.createNode();

	newNode.x = this.x;
	newNode.y = this.y;

	graph.selection = [];
	graph.selection.push(newNode);
	
	if (State.nodeMode()) {
		// nothing to do...
	} else if (State.lineMode()) {
		if (State.lastNode) {
			var lastNode = State.lastNode;
			graph.insertEdge(lastNode, newNode);
		}
	}
	State.lastNode = newNode;
	
	this.applied = 1;
	this.timestamp = new Date();
	this.buildLogMsg(newNode);
	this.affectedNodes.push(newNode);

	if (State.debug) {
		alert(this.timestamp + ": " + this.logMsg);
	}
};

CreateNodeAction.prototype.undo = function() {
	Designer.graph = this.graph;
};

function DeleteNodesAction() {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.affectedNodes = [];
	this.timestamp = undefined;
	this.graph = undefined;
}

DeleteNodesAction.prototype.buildLogMsg = function(nodeCount) {
	var verb = "";
	if (nodeCount === 1) {
		this.logMsg = "Node";
		verb = " was";		
	} else {
		this.logMsg = "Nodes";
		verb = " were";
	}
	this.logMsg = nodeCount + " " + this.logMsg;	
	this.logMsg += verb;
	this.logMsg += " deleted";
};

DeleteNodesAction.prototype.apply = function(graph) {

	this.graph = graph.clone();
	
	var nodeCount = 0;

	for(var i = 0; i < graph.selection.length; i++) {
		var node = graph.selection[i];
		this.affectedNodes.push(node);
		graph.removeNode(node);
		nodeCount++;
	}

	Designer.graph.selection=[];
	
	this.applied = 1;
	this.timestamp = new Date();
	this.buildLogMsg(nodeCount);
	
	if (State.debug) {
		alert(this.timestamp + ": " + this.logMsg);
	}
};

DeleteNodesAction.prototype.undo = function() {
	Designer.graph = this.graph.clone();
};

// TODO: Logbook
//         Zeigt actions an
//         Einträge sind selektierbar

Clickhandler.onDeleteNodes = function() {
	var action = new DeleteNodesAction();
	Designer.play(action);
};

function AddEdgeAction(source, sink) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.affectedNodes = [];
	this.timestamp = undefined;
	this.source = source;
	this.sink = sink;
	this.affectedNodes.push(source);
	this.affectedNodes.push(sink);
	this.graph = undefined;
}

AddEdgeAction.prototype.buildLogMsg = function() {
	this.logMsg = "Edge added between nodes " + this.source.id + " and " + this.sink.id;
};

AddEdgeAction.prototype.apply = function(graph) {

	this.graph = graph.clone();
	
	graph.insertEdge(this.source, this.sink);

	if (State.clearSelectionMode()) {
		graph.selection = [];
	}

	this.buildLogMsg();

	this.applied = 1;
	this.timestamp = new Date();

	if (State.debug) {
		alert(this.timestamp + ": " + this.logMsg);
	}
};


Clickhandler.onAddEdge = function() {
	if (Designer.graph.selection.length == 2) {
		var source = Designer.graph.selection[0];
		var sink = Designer.graph.selection[1];
		var action = new AddEdgeAction(source, sink);
		Designer.play(action);
	}
};

function CompleteSelectionAction(selection) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.timestamp = undefined;
	this.affectedNodes = selection.slice();
	this.graph = undefined;
}

CompleteSelectionAction.prototype.buildLogMsg = function(node) {
	var ids = "";
	for(var i = 0; i < this.affectedNodes.length; i++) {
		ids += "" + this.affectedNodes[i].id;
		if (i+1 < this.affectedNodes.length) {
			ids += ", ";
		}
	}
	this.logMsg = "Selection completed [ nodes = " + ids + "]";
};

CompleteSelectionAction.prototype.apply = function(graph) {

	this.graph = graph.clone();
	
	var iMax = this.affectedNodes.length;

	for(var i = 0; i < iMax; i++) {
		for(var j = i+1; j < iMax; j++) {
			var a = this.affectedNodes[i];
			var b = this.affectedNodes[j];
			Designer.graph.insertEdge(a, b);
		}
    }

	this.applied = 1;
	this.timestamp = new Date();
	this.buildLogMsg();

	if (State.debug) {
		alert(this.logMsg);
	}
};

Clickhandler.onLogbookCheck = function() {
	var visibility = undefined;
	var logbook = document.getElementById("logbook");
	
	if (State.logbookMode()) {
		visibility = "visible";
	} else {
		visibility = "hidden";
	};

	logbook.style.visibility = visibility;
};

Clickhandler.onCompleteSelection = function() {
	var selection = Designer.graph.selection.slice();
	var action = new CompleteSelectionAction(selection);
	Designer.play(action);
};

Clickhandler.onInvertSelection = function() {
    var newSelection = [];
    Designer.graph.nodes.forEach(function(s, i, o) {
		if (Designer.graph.selection.indexOf(s) == -1) {
			newSelection.push(s);
		}
    });
    var action = new SelectionChangeAction(newSelection);
	Designer.play(action);
};

Clickhandler.onSelectAll = function() {
	var newSelection = [];
    for(var i = 0; i < Designer.graph.nodes.length; i++) {
		var node = Designer.graph.nodes[i];
		newSelection.push(node);
    }
	var action = new SelectionChangeAction(newSelection);
	Designer.play(action);
};

function DeleteEdgesAction(selection) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.timestamp = undefined;
	this.affectedNodes = selection.slice();
	this.graph = undefined;
};

DeleteEdgesAction.prototype.buildLogMsg = function(node) {
	var ids = "";
	for(var i = 0; i < this.affectedNodes.length; i++) {
		ids += "" + this.affectedNodes[i].id;
		if (i+1 < this.affectedNodes.length) {
			ids += ", ";
		}
	}
	this.logMsg = "Edges removed for selected nodes [ " + ids + "]";
};

DeleteEdgesAction.prototype.apply = function(graph) {
	this.graph = graph.clone();

	for(var i = 0; i < this.affectedNodes.length; i++) {
		var node = this.affectedNodes[i];
		graph.removeEdges(node, this.affectedNodes);
	}
};



Clickhandler.onDeleteEdges = function() {
	var selection = Designer.graph.selection.slice();
	var action = new DeleteEdgesAction(selection);
	Designer.play(action);
};

function CanvasClickAction(x, y) {
	this.logMsg = "Action was not yet applied.";
	this.applied = 0;
	this.timestamp = undefined;
	this.affectedNodes = [];
	this.graph = undefined;
	this.x = x;
	this.y = y;
    this.nodeSelected = 0;	
};

CanvasClickAction.prototype.buildLogMsg = function(node) {
	this.logMsg = "Canvas area was clicked. A node was ";
	if (this.nodeSelected) {
		this.logMsg += "selected ";
	} else {
		this.logMsg += "created ";
	}
//	this.logMsg += "(id=" + this.affectedNodes[0].id + ")";
};

var CaptureRect = CaptureRect || {};

CaptureRect.x1 = 0;
CaptureRect.y1 = 0;
CaptureRect.x2 = 0;
CaptureRect.y2 = 0;
CaptureRect.inProgress = 0;
CaptureRect.action = undefined;

CaptureRect.reset = function() {
	CaptureRect.x1 = 0;
	CaptureRect.y1 = 0;
	CaptureRect.x2 = 0;
	CaptureRect.y2 = 0;
	CaptureRect.inProgress = 0;
};

CanvasClickAction.prototype.apply = function(graph) {

	this.graph = graph.clone();

	for(var i = 0; i < Designer.graph.nodes.length; i++) {
		var node = Designer.graph.nodes[i];
		if (Clickhandler.isClose(node, this.x, this.y) == 1) {
			Designer.graph.selectNode(node);
			this.nodeSelected=1;
			this.affectedNodes.push(node);			
			break;
		}
	}

	// this is the auto-edge feature (whenever two nodes are selected
	// edge is inserted between nodes and selection is cleared
	if (State.autoEdgeMode() && Designer.graph.selection.length == 2) {
		var source = Designer.graph.selection[0];
		var sink = Designer.graph.selection[1];
		Designer.graph.insertEdge(source, sink);
		Designer.graph.selection = [];
	}

	if (this.nodeSelected === 0) {
		var newNode = graph.createNode();
		this.affectedNodes.push(newNode);
		
		newNode.x = this.x;
		newNode.y = this.y;

		graph.selection = [];
		graph.selection.push(newNode);
		
		if (State.nodeMode()) {
			// nothing to do...
		} else if (State.lineMode()) {
			if (State.lastNode) {
				var lastNode = State.lastNode;
				graph.insertEdge(lastNode, newNode);
			}
		}
		State.lastNode = newNode;
	}

	this.applied = 1;
	this.timestamp = new Date();
	this.buildLogMsg();
};

CanvasClickAction.prototype.undo = function() {
	Designer.graph = this.graph;
}

Clickhandler.isClose = function(node, x, y) {
	var dx = x - node.x;
	var dy = y - node.y;
	var result = 0;
	if (Math.sqrt(dx*dx + dy*dy) < State.closeDistance) {
		result = 1;
	}
	return result;
};

Clickhandler.onCanvasClick = function(event) {

	var x = event.pageX - Designer.xOffset;
    var y = event.pageY - Designer.yOffset;

	var action = new CanvasClickAction(x, y);
	Designer.play(action);
};

Clickhandler.onUndoLastAction = function() {
	var iMax = Designer.actionLog.length-1;
	var action = Designer.actionLog[iMax];
	Designer.actionLog.splice(iMax, 1);
	action.undo();
	Designer.redraw();
};


Clickhandler.RandomNodes = Clickhandler.RandomNodes || {};

Clickhandler.RandomNodes.topLeft_x = 0;
Clickhandler.RandomNodes.topLeft_y = 0;
Clickhandler.RandomNodes.bottomRight_x = 0;
Clickhandler.RandomNodes.bottomRight_y = 0;
Clickhandler.RandomNodes.inProgress = 0;

Clickhandler.doRandomNodes = function() {
	Clickhandler.RandomNodes.inProgress = 0;	
	var numNodes = 10;
	var w = Clickhandler.RandomNodes.bottomRight_x - Clickhandler.RandomNodes.topLeft_x;
	var h = Clickhandler.RandomNodes.bottomRight_y - Clickhandler.RandomNodes.topLeft_y;
	for (var i=0 ; i<numNodes; i++) {
		var x = Clickhandler.RandomNodes.topLeft_x + Math.random() * w;
		var y = Clickhandler.RandomNodes.topLeft_y + Math.random() * h;
		var action = new CreateNodeAction(x, y);
		Designer.play(action);
	}
};

Clickhandler.doGridNodes = function() {
	Clickhandler.RandomNodes.inProgress = 0;	
	var w = Clickhandler.RandomNodes.bottomRight_x - Clickhandler.RandomNodes.topLeft_x;
	var h = Clickhandler.RandomNodes.bottomRight_y - Clickhandler.RandomNodes.topLeft_y;

	var y = Clickhandler.RandomNodes.topLeft_y;
	while (y < Clickhandler.RandomNodes.topLeft_y + h) {
		var x = Clickhandler.RandomNodes.topLeft_x;		
		while (x < Clickhandler.RandomNodes.topLeft_x + w) {
			var action = new CreateNodeAction(x, y);
			Designer.play(action);
			x+=50;
		}
		y+=50;
	}
};

Clickhandler.onRandomNodes = function() {

	Designer.canvas.onmousedown = function(evt) {
		Clickhandler.RandomNodes.inProgress = 1;
		Clickhandler.RandomNodes.topLeft_x = evt.clientX;
		Clickhandler.RandomNodes.topLeft_y = evt.clientY;
		Designer.canvas.onmousemove = function(evt) {
			Designer.redraw();
			var w = evt.clientX - Clickhandler.RandomNodes.topLeft_x;
			var h = evt.clientY - Clickhandler.RandomNodes.topLeft_y;
			Designer.drawSelectionRect(Clickhandler.RandomNodes.topLeft_x, Clickhandler.RandomNodes.topLeft_y, w, h);
		};
	};

	Designer.canvas.onmouseup = function(evt) {
		Clickhandler.RandomNodes.bottomRight_x = evt.clientX;
		Clickhandler.RandomNodes.bottomRight_y = evt.clientY;
		Clickhandler.doRandomNodes();
		Clickhandler.RandomNodes.inProgress = 0;
		Clickhandler.RandomNodes.topLeft_x = 0;
		Clickhandler.RandomNodes.topLeft_y = 0;
		Clickhandler.RandomNodes.bottomRight_x = 0;
		Clickhandler.RandomNodes.bottomRight_y = 0;
		Designer.canvas.onmouseup = undefined;
		Designer.canvas.onmousemove = undefined;
		Designer.canvas.onmousedown = undefined;
	};

};

Clickhandler.onInsertGrid = function() {

	Designer.canvas.onmousedown = function(evt) {
		Clickhandler.RandomNodes.inProgress = 1;
		Clickhandler.RandomNodes.topLeft_x = evt.clientX;
		Clickhandler.RandomNodes.topLeft_y = evt.clientY;
		Designer.canvas.onmousemove = function(evt) {
			Designer.redraw();
			var w = evt.clientX - Clickhandler.RandomNodes.topLeft_x;
			var h = evt.clientY - Clickhandler.RandomNodes.topLeft_y;
			Designer.drawSelectionRect(Clickhandler.RandomNodes.topLeft_x, Clickhandler.RandomNodes.topLeft_y, w, h);
		};
	};

	Designer.canvas.onmouseup = function(evt) {
		Clickhandler.RandomNodes.bottomRight_x = evt.clientX;
		Clickhandler.RandomNodes.bottomRight_y = evt.clientY;
		Clickhandler.doGridNodes();
		Clickhandler.RandomNodes.inProgress = 0;
		Clickhandler.RandomNodes.topLeft_x = 0;
		Clickhandler.RandomNodes.topLeft_y = 0;
		Clickhandler.RandomNodes.bottomRight_x = 0;
		Clickhandler.RandomNodes.bottomRight_y = 0;
		Designer.canvas.onmouseup = undefined;
		Designer.canvas.onmousemove = undefined;
		Designer.canvas.onmousedown = undefined;
	};

};
Clickhandler.onTriangulate = function() {
	var orderedNodes = [];
	var nodes = Designer.graph.selection.slice();

	while (nodes.length > 0) {
		var minX = 2*Designer.canvas.width;
		var node = undefined;
		var nodeIndex = -1;
		for (var i=0; i<nodes.length; i++) {
			if (nodes[i].x < minX) {
				node = nodes[i];
				minX = node.x;
				nodeIndex = i;
			}
		}
		orderedNodes.push(node);
		nodes.splice(nodeIndex, 1);
	}

	for (var i=0; i<orderedNodes.length-2; i++) {
		Designer.graph.insertEdge(orderedNodes[i], orderedNodes[i+1]);
		Designer.graph.insertEdge(orderedNodes[i], orderedNodes[i+2]);
		Designer.graph.insertEdge(orderedNodes[i+1], orderedNodes[i+2]);
	}
	Designer.redraw();
};


Clickhandler.drawScene = function() {
	Designer.canvas.width		 = window.innerWidth;
    Designer.canvas.height		 = window.innerHeight;

	// clear scene and then draw from scratch
	Designer.ctx.clearRect ( 0 , 0 , Designer.canvas.width , Designer.canvas.height );

	// Draw background
	Designer.ctx.fillStyle = Designer.bgcolor;
	Designer.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

	var node = undefined;
		
	for(var k = 0; k < Designer.graph.edges.length; k++) {
		var edge = Designer.graph.edges[k];
		var seed = 0;
		Designer.drawEdge(edge, seed);
	}

	for(var i = 0; i < Designer.graph.nodes.length; i++) {
		node = Designer.graph.nodes[i];
		Designer.drawNode(node);
	}

	for(var j = 0; j < Designer.graph.selection.length; j++) {
		node = Designer.graph.selection[j];
		Designer.drawNodeSelection(node);
	}
};

Clickhandler.register = function() {
    document.getElementById("deleteselection").onclick=Clickhandler.onDeleteNodes;
    document.getElementById("addedge").onclick=Clickhandler.onAddEdge;
    document.getElementById("complete").onclick=Clickhandler.onCompleteSelection;
    document.getElementById("invertselection").onclick=Clickhandler.onInvertSelection;
    document.getElementById("selectall").onclick=Clickhandler.onSelectAll;
    document.getElementById("deleteedges").onclick=Clickhandler.onDeleteEdges;
	document.getElementById("undobtn").onclick=Clickhandler.onUndoLastAction;
	document.getElementById("randnodes").onclick=Clickhandler.onRandomNodes;
	document.getElementById("grid").onclick=Clickhandler.onInsertGrid;	
	document.getElementById("triangulate").onclick=Clickhandler.onTriangulate;
	document.getElementById("logbookChkbx").onclick=Clickhandler.onLogbookCheck;
	window.addEventListener("resize", Designer.redraw);
};

Clickhandler.unregister = function() {
    document.getElementById("deleteselection").onclick=undefined;
    document.getElementById("addedge").onclick=undefined;
    document.getElementById("complete").onclick=undefined;
    document.getElementById("invertselection").onclick=undefined;
    document.getElementById("selectall").onclick=undefined;
    document.getElementById("deleteedges").onclick=undefined;
};

var State = State || {};

/*
 Variable: closeDistance
 Two nodes are considered close if dist between
 the two is more then this value.
*/

State.closeDistance = 25;

/*
 Variable: lastNode
 If lineMode is activated designer has to keep track on
 the last created node.
*/
State.lastNode = 0;

/*
 Variable debug
 Wether or not Designer is running in debug mode.
*/

State.debug = 0;

/*
 In LineMode a new node is created onClick. It is immediatly
 connected two the last created node.
 */

State.lineMode = function() {
    return document.getElementById("linemode").checked;
};

State.logbookMode = function() {
	return document.getElementById("logbookChkbx").checked;
};

/*
 In nodeMode click creates a new node.
*/

State.nodeMode = function() {
    return document.getElementById("nodemode").checked;
};

/*
 In autoEdgeMode whenever two nodes are selected an edge
 is added between them and the selection is cleared.
 */
State.autoEdgeMode = function() {
    return document.getElementById("autoedge").checked;
};

State.clearSelectionMode = function() {
	return document.getElementById("clearselection").checked;
};

var Designer = Designer || {};

Designer.graph			 = undefined;
Designer.lastNode		 = undefined;
Designer.ctx			 = undefined;
Designer.canvas			 = undefined;
Designer.bgcolor         = "#27556C";
Designer.actionQueue     = [];
Designer.actionLog       = [];

Designer.startUp = function() {
	
	Clickhandler.register();

	this.lastNode = undefined;
	this.graph = new Graph();

    var bodyTag   = document.body;
    var divTag    = document.createElement("div");
    var canvasTag = document.createElement("canvas");

    divTag.style.position	 = 'absolute';
    divTag.style.left		 = 0;
    divTag.style.top		 = 0;
    divTag.style.margin		 = 0;
    divTag.style.padding     = 0;
    
    canvasTag.style.position = 'absolute';
    canvasTag.style.left	 = 0;
    canvasTag.style.top		 = 0;
    canvasTag.style.margin	 = 0;
    canvasTag.style.padding	 = 0;
    
    divTag.appendChild(canvasTag);
	
    bodyTag.appendChild(divTag);
    
    this.canvas = document.getElementsByTagName("canvas")[0];
    this.ctx	= this.canvas.getContext("2d");
    this.canvas.width		 = window.innerWidth;
    this.canvas.height		 = window.innerHeight;

    this.canvas.onmousedown = Clickhandler.onCanvasClick;

	this.ctx.clearRect ( 0 , 0 , Designer.canvas.width , Designer.canvas.height );

	this.xOffset             = this.canvas.offsetLeft;
    this.yOffset             = this.canvas.offsetTop;

	// Draw background
	this.ctx.fillStyle = this.bgcolor;
	this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
};

Designer.drawEdge = function(edge, seed) {
	this.ctx.lineWidth = 1;
	this.ctx.strokeStyle = "#D17F69";
	this.ctx.beginPath();
	this.ctx.moveTo(edge.source.x, edge.source.y);
	var cpx = edge.source.x + (edge.sink.x - edge.source.x)/2.0;
	var cpy = edge.source.y + (edge.sink.y - edge.source.y)/2.0;
	var len = Math.sqrt(cpx*cpx + cpy*cpy);
	var dx = -1.0 * cpy / len;
	var dy = cpx / len;
	this.ctx.quadraticCurveTo(cpx + seed * dx, cpy + seed * dy, edge.sink.x, edge.sink.y);
	this.ctx.stroke();
	this.ctx.closePath();
}

Designer.drawNodeSelection = function(node) {
    this.ctx.lineWidth = 2;
    this.ctx.strokeStyle = "#D17F69";
    this.ctx.beginPath();
    this.ctx.arc(node.x, node.y, 17, 0, 2*Math.PI);
    this.ctx.stroke();
    this.ctx.closePath();
};

Designer.drawSelectionRect = function(x, y, w, h) {
	this.ctx.strokeStyle = "#29794C";
	this.ctx.lineWidth = 1;
	this.ctx.beginPath();
	this.ctx.strokeRect(x, y, w, h);
	this.ctx.closePath();
};

Designer.drawNode = function(node) {

    var color1 = "#AA7539";
    var color2 = "#AA5039";
    var color3 = "#29794C";
    var color4 = "#825016";

    this.ctx.fillStyle = color3;
    this.ctx.beginPath();
    this.ctx.arc(node.x, node.y, 15, 0, 2*Math.PI);
    this.ctx.fill();
    
    this.ctx.fillStyle = color1;
    this.ctx.beginPath();
    this.ctx.arc(node.x, node.y, 10, 0, 2*Math.PI);
    this.ctx.fill();

    this.ctx.fillStyle = color2;
    this.ctx.beginPath();
    this.ctx.arc(node.x, node.y, 5, 0, 2*Math.PI);
    this.ctx.fill();

    this.ctx.closePath();
};

Designer.play = function(action) {
	this.actionQueue.push(action);
	this.actionLog.push(action);
	
	for(var i = 0; i < this.actionQueue.length; i++) {
		this.actionQueue[i].apply(this.graph);
	}
	this.actionQueue = [];
	Logbook.append(action);
	Designer.redraw();
};

Designer.redraw = function() {
	Clickhandler.drawScene();
};


Designer.startUp();
